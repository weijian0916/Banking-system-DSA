import datetime

# ==================================================
# Node Class
# Each node represents ONE transaction
# ==================================================
class Node:
    def __init__(self, amount, transaction_type):
        self.amount = amount                      # Transaction amount
        self.transaction_type = transaction_type  # Deposit or Withdrawal
        self.date = datetime.datetime.now()       # Date & time of transaction
        self.next = None                          # Pointer to next node


# ==================================================
# Stack for Undo Operation
# Stack is implemented using Python list
# ==================================================
undo = []   # This list acts as a STACK

def is_stack_empty():
    """
    Check whether the undo stack is empty
    Returns True if empty, False otherwise
    """
    return len(undo) == 0

def push_undo(transaction_node):
    """
    PUSH operation
    Stores the latest transaction into the undo stack
    """
    undo.append(transaction_node)

def pop_undo():
    """
    POP operation
    Removes and returns the most recent transaction
    """
    if is_stack_empty():
        return None
    return undo.pop()

def peek_undo():
    """
    PEEK operation
    Returns the most recent transaction WITHOUT removing it
    """
    if is_stack_empty():
        return None
    return undo[-1]


# ==================================================
# Undo Latest Transaction
# ==================================================
def undo_latest(head):
    """
    Undo the most recent transaction using stack POP
    """
    if is_stack_empty():
        print("No action to undo!")
        return head

    last_node = pop_undo()
    print(f"Undo {last_node.transaction_type} of ${last_node.amount}")

    # If only one transaction exists
    if head == last_node:
        return None

    # Traverse linked list to find the node before last_node
    current = head
    while current.next is not None and current.next != last_node:
        current = current.next

    if current.next == last_node:
        current.next = None

    return head


# ==================================================
# Linked List Operations
# ==================================================
def insertAtEnd(head, amount, transaction_type):
    """
    Insert a new transaction node at the end of the linked list
    """
    newNode = Node(amount, transaction_type)

    if head is None:
        return newNode

    current = head
    while current.next is not None:
        current = current.next

    current.next = newNode
    return head

def traverseList(head):
    """
    Display all transaction records
    """
    if head is None:
        print("No transaction yet")
        return

    current = head
    while current is not None:
        date_str = current.date.strftime("%Y-%m-%d")
        print(f"Date: {date_str} | Type: {current.transaction_type} | Amount: ${current.amount}")
        current = current.next

def calculateBalance(head):
    """
    Calculate current account balance
    """
    balance = 0
    current = head

    while current is not None:
        if current.transaction_type == "Deposit":
            balance += current.amount
        else:
            balance -= current.amount
        current = current.next

    return balance

def searchByDate(head, search_date):
    """
    Search transactions based on date (YYYY-MM-DD)
    """
    if head is None:
        print("No transactions to search")
        return

    found = False
    current = head
    print(f"Searching for transactions on {search_date}")

    while current is not None:
        transaction_date = current.date.strftime("%Y-%m-%d")
        if transaction_date == search_date:
            found = True
            print(f"Date: {transaction_date} | Type: {current.transaction_type} | Amount: ${current.amount}")
        current = current.next

    if not found:
        print("No transactions found on that date.")


# ==================================================
# Main Menu Function
# ==================================================
def history():
    head = None   # Head of linked list

    while True:
        print("\n====== Transaction Menu ======")
        print("1. Deposit")
        print("2. Withdrawal")
        print("3. Show transaction history")
        print("4. Search transactions by date")
        print("5. Show current balance")
        print("6. Undo latest transaction ")
        print("7. Peek next undo ")
        print("8. Exit")

        try:
            choice = int(input("Choose an option (1-8): "))
        except ValueError:
            print("Please enter a valid number.")
            continue

        # ------------------ Deposit ------------------
        if choice == 1:
            amount = float(input("Enter amount to Deposit: "))
            head = insertAtEnd(head, amount, "Deposit")

            # Push last transaction into undo stack
            curr = head
            while curr.next:
                curr = curr.next
            push_undo(curr)

            print("Deposit successful!")

        # ---------------- Withdrawal -----------------
        elif choice == 2:
            amount = float(input("Enter amount to Withdraw: "))
            if calculateBalance(head) >= amount:
                head = insertAtEnd(head, amount, "Withdrawal")

                curr = head
                while curr.next:
                    curr = curr.next
                push_undo(curr)

                print("Withdrawal successful!")
            else:
                print("Not enough balance!")

        # ------------ Show History -------------------
        elif choice == 3:
            traverseList(head)

        # ------------ Search by Date -----------------
        elif choice == 4:
            date_input = input("Enter date (YYYY-MM-DD): ")
            searchByDate(head, date_input)

        # ------------ Show Balance -------------------
        elif choice == 5:
            print(f"Current Balance: ${calculateBalance(head):.2f}")

        # ------------ Undo (POP) ---------------------
        elif choice == 6:
            head = undo_latest(head)

        # ------------ Peek (PEEK) --------------------
        elif choice == 7:
            top = peek_undo()
            if top:
                print(f"Next undo: {top.transaction_type} of ${top.amount}")
            else:
                print("Undo stack is empty.")

        # ---------------- Exit -----------------------
        elif choice == 8:
            print("Exiting program...")
            break

        else:
            print("Invalid option.")


# ==================================================
# Program Execution
# ==================================================
history()
